// –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
import transactionOptimizationService from './transactionOptimizationService';
import gasOptimizationService from './gasOptimizationService';
import nonceOptimizationService from './nonceOptimizationService';

class BlockchainOptimizationIntegration {
  constructor() {
    this.isInitialized = new Map();
    this.activeChains = new Set();
    
    // –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    this.integratedMetrics = new Map();
    
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–µ—Ç–µ–π
    this.integrationConfig = {
      6342: { // MegaETH - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
        enableAllOptimizations: true,
        preSignedPoolSize: 100,
        gasStrategy: 'ultra_fast',
        nonceStrategy: 'pre_signed_pool',
        parallelSigning: true,
        burstMode: true,
        metricsUpdateInterval: 2000
      },
      31337: { // Foundry - –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞
        enableAllOptimizations: true,
        preSignedPoolSize: 80,
        gasStrategy: 'minimal',
        nonceStrategy: 'pre_signed_pool',
        parallelSigning: true,
        burstMode: true,
        metricsUpdateInterval: 3000
      },
      50311: { // Somnia - —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
        enableAllOptimizations: true,
        preSignedPoolSize: 60,
        gasStrategy: 'balanced',
        nonceStrategy: 'hybrid',
        parallelSigning: false,
        burstMode: false,
        metricsUpdateInterval: 4000
      },
      1313161556: { // RISE - –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
        enableAllOptimizations: true,
        preSignedPoolSize: 50,
        gasStrategy: 'optimized',
        nonceStrategy: 'hybrid',
        parallelSigning: false,
        burstMode: false,
        metricsUpdateInterval: 5000
      }
    };
  }

  // –ü–æ–ª–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π –¥–ª—è —Å–µ—Ç–∏
  async initializeOptimizations(chainId, walletClient, publicClient, embeddedWallet) {
    const chainKey = chainId.toString();
    
    if (this.isInitialized.get(chainKey)) {
      console.log(`‚úÖ Optimizations already initialized for chain ${chainId}`);
      return this.getOptimizationStatus(chainId);
    }

    console.log(`üöÄ Initializing integrated blockchain optimizations for chain ${chainId}`);
    
    const config = this.integrationConfig[chainId] || this.integrationConfig[31337]; // Fallback –∫ Foundry config
    const address = embeddedWallet.address;
    
    try {
      // 1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥–∞–∑–æ–≤—ã—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π
      console.log(`‚õΩ Initializing gas optimizations...`);
      const gasParams = await gasOptimizationService.getOptimizedGasParams(chainId, publicClient);
      
      // 2. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è nonce –º–µ–Ω–µ–¥–∂–µ—Ä–∞
      console.log(`üéØ Initializing nonce optimizations...`);
      const initialNonce = await nonceOptimizationService.initializeNonceManager(
        chainId, 
        address, 
        publicClient, 
        config.nonceStrategy
      );
      
      // 3. –†–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–∏–µ nonce –¥–ª—è –ø—É–ª–∞ –ø—Ä–µ–¥–ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
      console.log(`üìù Reserving nonces for pre-signed pool...`);
      const nonceReservation = await nonceOptimizationService.reserveNonceRange(
        chainId, 
        address, 
        config.preSignedPoolSize, 
        publicClient
      );
      
      // 4. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É–ª–∞ –ø—Ä–µ–¥–ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
      console.log(`üéÆ Initializing pre-signed transaction pool...`);
      const poolSize = await transactionOptimizationService.initializePool(
        chainId,
        walletClient,
        gasParams,
        nonceReservation.startNonce,
        config.preSignedPoolSize
      );
      
      // 5. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫
      this.initializeIntegratedMetrics(chainId, config);
      
      // –û—Ç–º–µ—á–∞–µ–º –∫–∞–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
      this.isInitialized.set(chainKey, true);
      this.activeChains.add(chainId);
      
      const status = {
        chainId,
        initialized: true,
        config,
        gasParams: {
          maxFeePerGas: Number(gasParams.maxFeePerGas) / 1e9,
          maxPriorityFeePerGas: Number(gasParams.maxPriorityFeePerGas) / 1e9,
          strategy: gasParams.strategy
        },
        nonceStatus: nonceOptimizationService.getNonceStatus(chainId, address),
        poolStatus: transactionOptimizationService.getPoolStatus(chainId),
        reservedNonces: nonceReservation,
        poolSize,
        timestamp: new Date().toISOString()
      };
      
      console.log(`‚úÖ Integrated optimizations initialized successfully for chain ${chainId}`);
      console.log(`üìä Status:`, {
        gasStrategy: gasParams.strategy,
        nonceStrategy: config.nonceStrategy,
        poolSize: poolSize,
        reservedNonces: nonceReservation.count
      });
      
      return status;
      
    } catch (error) {
      console.error(`‚ùå Failed to initialize optimizations for chain ${chainId}:`, error);
      
      // –ß–∞—Å—Ç–∏—á–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö
      this.isInitialized.set(chainKey, false);
      
      return {
        chainId,
        initialized: false,
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫
  initializeIntegratedMetrics(chainId, config) {
    const chainKey = chainId.toString();
    
    this.integratedMetrics.set(chainKey, {
      chainId,
      config,
      startTime: Date.now(),
      totalTransactions: 0,
      successfulTransactions: 0,
      totalBlockchainTime: 0,
      gasUsage: {
        totalGasUsed: 0,
        averageGasPrice: 0,
        gasEfficiency: 0
      },
      nonceEfficiency: {
        totalAllocated: 0,
        totalUsed: 0,
        wastedNonces: 0
      },
      poolPerformance: {
        poolHits: 0,
        poolMisses: 0,
        refillCount: 0
      },
      lastUpdate: Date.now()
    });
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫
    setInterval(() => {
      this.updateIntegratedMetrics(chainId);
    }, config.metricsUpdateInterval);
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫
  updateIntegratedMetrics(chainId) {
    const chainKey = chainId.toString();
    const metrics = this.integratedMetrics.get(chainKey);
    
    if (!metrics) return;
    
    try {
      // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ—Ç –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
      const transactionStats = transactionOptimizationService.getPerformanceStats(chainId);
      const gasStats = gasOptimizationService.getPerformanceStats(chainId);
      const nonceStatus = this.getFirstActiveNonceManager(chainId);
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
      metrics.totalTransactions = transactionStats.totalTransactions;
      metrics.successfulTransactions = transactionStats.successfulTransactions;
      metrics.totalBlockchainTime = transactionStats.averageBlockchainTime * transactionStats.totalTransactions;
      
      if (gasStats) {
        metrics.gasUsage = {
          totalGasUsed: gasStats.averageGasUsed * gasStats.totalTransactions,
          averageGasPrice: gasStats.averageGasPrice || 0,
          gasEfficiency: gasStats.cacheHitRate
        };
      }
      
      if (nonceStatus) {
        metrics.nonceEfficiency = {
          totalAllocated: nonceStatus.totalAllocated,
          totalUsed: nonceStatus.totalUsed,
          wastedNonces: nonceStatus.totalAllocated - nonceStatus.totalUsed
        };
      }
      
      // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—É–ª–∞
      const poolStatus = transactionOptimizationService.getPoolStatus(chainId);
      if (poolStatus.status !== 'not_initialized') {
        metrics.poolPerformance.poolHits = metrics.totalTransactions; // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –º–µ—Ç—Ä–∏–∫–∞
      }
      
      metrics.lastUpdate = Date.now();
      
    } catch (error) {
      console.error(`Error updating integrated metrics for chain ${chainId}:`, error);
    }
  }

  // –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ nonce manager –¥–ª—è –º–µ—Ç—Ä–∏–∫
  getFirstActiveNonceManager(chainId) {
    // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ –∞–¥—Ä–µ—Å–∞
    const managers = nonceOptimizationService.nonceManagers;
    for (const [key, manager] of managers.entries()) {
      if (key.startsWith(`${chainId}-`)) {
        return nonceOptimizationService.getNonceStatus(chainId, manager.address);
      }
    }
    return null;
  }

  // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
  async sendOptimizedTransaction(chainId) {
    const chainKey = chainId.toString();
    
    if (!this.isInitialized.get(chainKey)) {
      throw new Error(`Optimizations not initialized for chain ${chainId}`);
    }

    const startTime = performance.now();
    let success = false;
    let result = null;
    
    try {
      console.log(`üöÄ Sending optimized transaction for chain ${chainId}`);
      
      // 1. –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ–¥–ø–æ–¥–ø–∏—Å–∞–Ω–Ω—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –∏–∑ –ø—É–ª–∞
      const signedTx = await transactionOptimizationService.getNextTransaction(chainId);
      
      // 2. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é (–∑–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –∫–æ–¥–æ–º –æ—Ç–ø—Ä–∞–≤–∫–∏)
      result = await this.sendRawTransactionOptimized(chainId, signedTx);
      
      success = true;
      console.log(`‚úÖ Optimized transaction sent successfully:`, result);
      
      return result;
      
    } catch (error) {
      console.error(`‚ùå Optimized transaction failed:`, error);
      throw error;
      
    } finally {
      const blockchainTime = performance.now() - startTime;
      
      // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏ –≤–æ –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã
      this.recordTransactionMetrics(chainId, blockchainTime, success, result);
    }
  }

  // –ó–∞–ø–∏—Å—å –º–µ—Ç—Ä–∏–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –≤–æ –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã
  recordTransactionMetrics(chainId, blockchainTime, success, result) {
    try {
      // 1. –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ —Å–µ—Ä–≤–∏—Å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
      transactionOptimizationService.recordPerformanceMetric(chainId, 'transaction_execution', {
        blockchainTime: Math.round(blockchainTime),
        success,
        timestamp: Date.now()
      });
      
      // 2. –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≥–∞–∑–æ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞)
      if (result && result.gasUsed && result.effectiveGasPrice) {
        gasOptimizationService.recordGasUsage(
          chainId,
          result.gasUsed,
          result.effectiveGasPrice,
          success,
          blockchainTime
        );
      }
      
      // 3. –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ nonce (–µ—Å–ª–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è —É—Å–ø–µ—à–Ω–∞)
      if (success && result && result.nonce) {
        // –ó–¥–µ—Å—å –Ω—É–∂–µ–Ω –∞–¥—Ä–µ—Å - –≤ —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –æ–Ω –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω
        // nonceOptimizationService.confirmNonceUsage(chainId, address, result.nonce);
      }
      
      // 4. –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
      this.updateIntegratedMetrics(chainId);
      
    } catch (error) {
      console.error('Error recording transaction metrics:', error);
    }
  }

  // –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∑–∞–º–µ–Ω–µ–Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π)
  async sendRawTransactionOptimized(chainId, signedTx) {
    // –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –∫–æ–¥–æ–º sendRawTransaction
    // –ü–æ–∫–∞ —á—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –º–æ–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    return {
      hash: '0x' + Math.random().toString(16).substring(2),
      nonce: 0, // –î–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ä–µ–∞–ª—å–Ω—ã–π nonce
      gasUsed: 21000,
      effectiveGasPrice: 1000000000, // 1 gwei
      status: 1
    };
  }

  // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π
  getOptimizationStatus(chainId) {
    const chainKey = chainId.toString();
    
    if (!this.isInitialized.get(chainKey)) {
      return {
        chainId,
        initialized: false,
        message: 'Optimizations not initialized'
      };
    }

    const config = this.integrationConfig[chainId];
    const metrics = this.integratedMetrics.get(chainKey);
    
    return {
      chainId,
      initialized: true,
      config,
      performance: {
        totalTransactions: metrics?.totalTransactions || 0,
        successRate: metrics?.totalTransactions > 0 ? 
          (metrics.successfulTransactions / metrics.totalTransactions * 100).toFixed(1) : 0,
        averageBlockchainTime: metrics?.totalTransactions > 0 ?
          Math.round(metrics.totalBlockchainTime / metrics.totalTransactions) : 0,
        uptime: metrics ? Date.now() - metrics.startTime : 0
      },
      services: {
        transactionPool: transactionOptimizationService.getPoolStatus(chainId),
        gasOptimization: gasOptimizationService.getPerformanceStats(chainId),
        nonceManagement: this.getFirstActiveNonceManager(chainId)
      },
      lastUpdate: metrics?.lastUpdate ? new Date(metrics.lastUpdate).toISOString() : null
    };
  }

  // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞ –ø–æ –≤—Å–µ–º –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º
  generateComprehensiveReport() {
    const report = {
      timestamp: new Date().toISOString(),
      activeChains: Array.from(this.activeChains),
      totalOptimizedChains: this.activeChains.size,
      services: {
        transactionOptimization: transactionOptimizationService.generateOptimizationReport,
        gasOptimization: gasOptimizationService.generateDiagnosticReport(),
        nonceOptimization: nonceOptimizationService.generateDiagnosticReport()
      },
      integratedMetrics: {},
      recommendations: []
    };

    // –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –∞–∫—Ç–∏–≤–Ω–æ–π —Å–µ—Ç–∏
    for (const chainId of this.activeChains) {
      const status = this.getOptimizationStatus(chainId);
      report.integratedMetrics[chainId] = status;
      
      // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
      const recommendations = this.generateOptimizationRecommendations(chainId, status);
      if (recommendations.length > 0) {
        report.recommendations.push({
          chainId,
          recommendations
        });
      }
    }

    return report;
  }

  // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
  generateOptimizationRecommendations(chainId, status) {
    const recommendations = [];
    const performance = status.performance;
    
    // –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    if (performance.averageBlockchainTime > 5000) {
      recommendations.push({
        type: 'performance',
        priority: 'high',
        message: 'High transaction times detected',
        action: 'Consider increasing pool size or enabling burst mode'
      });
    }
    
    if (performance.successRate < 95) {
      recommendations.push({
        type: 'reliability',
        priority: 'high',
        message: 'Low success rate detected',
        action: 'Check gas parameters and network connectivity'
      });
    }
    
    // –ê–Ω–∞–ª–∏–∑ –ø—É–ª–∞
    const poolStatus = status.services.transactionPool;
    if (poolStatus.status === 'critical' || poolStatus.status === 'low') {
      recommendations.push({
        type: 'pool_management',
        priority: 'medium',
        message: 'Transaction pool running low',
        action: 'Increase batch size or reduce refill threshold'
      });
    }
    
    return recommendations;
  }

  // –°–±—Ä–æ—Å –≤—Å–µ—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π –¥–ª—è —Å–µ—Ç–∏ (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
  resetOptimizations(chainId) {
    const chainKey = chainId.toString();
    
    // –û—á–∏—â–∞–µ–º –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã
    transactionOptimizationService.clearPool(chainId);
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º nonce managers –¥–ª—è —ç—Ç–æ–π —Å–µ—Ç–∏
    for (const [key] of nonceOptimizationService.nonceManagers.entries()) {
      if (key.startsWith(`${chainId}-`)) {
        const address = key.split('-')[1];
        nonceOptimizationService.resetManager(chainId, address);
      }
    }
    
    // –û—á–∏—â–∞–µ–º –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    this.isInitialized.set(chainKey, false);
    this.activeChains.delete(chainId);
    this.integratedMetrics.delete(chainKey);
    
    console.log(`üîÑ Reset all optimizations for chain ${chainId}`);
  }
}

// –°–æ–∑–¥–∞–µ–º singleton —ç–∫–∑–µ–º–ø–ª—è—Ä
const blockchainOptimizationIntegration = new BlockchainOptimizationIntegration();

export default blockchainOptimizationIntegration;